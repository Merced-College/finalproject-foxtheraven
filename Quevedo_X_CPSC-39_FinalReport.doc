Xandra Quevedo
CPSC-39-12705
8 December 2025

Dungeons of Java
For my final project, I created the basis of a simple text adventure game titled Dungeons of Java. The game is fully terminal-based and uses no graphics. It presents the player with a small dungeon to explore, enemies to fight, and items to find. In an attempt to implement some legitimate game design, the combat of the game is based on reacting to descriptions of the enemy’s behavior. While the game is unfinished and only one combat sequence is currently fully operational, that sequence does demonstrate the basic idea of this design concept. The player is rewarded for correctly interpreting the first enemy’s behavior and reacting appropriately, and they are punished for misinterpreting that behavior. Dungeons of Java, in its present iteration, is a very simple and partially unfinished, unrefined text adventure game, but I believe it still has the potential to be entertaining through its design. In its present form, it is simply exciting to me that its main gameplay works as expected. I hope to expand upon it in the future.
 

Algorithms
CONVERT TO FLOWCHARTS
The following algorithm is what runs when a rat is encountered and after a separate method, actionCall, is called with similar arguments to what are utilized in the combat sequence algorithm. This is likely the most complex, and perhaps convoluted, algorithm within Dungeons of Java. The combat sequence operates mainly by checking the number of the current round and the player’s inputted action. The rat’s displayed behavior changes based on whether the round is odd or even, and the correct action for the player to take changes based on the rat’s behavior. For example, the rat is initially “ready to lunge,” so the correct action is to protect yourself. If the player tries to attack, they will land a hit, but they will also take damage. This concept is based on a written version of common enemy and boss design in games, where you have to learn your foe’s attack patterns and telling behavior. 
I created this algorithm solely by myself by running through how to implement the gameplay that I wanted to create. I knew I wanted to alternate enemy behavior, so I decided to track the round number and whether it was odd or even. The most difficult part was figuring out how to ensure that no code was repeated unnecessarily. Initially, this method checked for player death in both rounds. However, I realized I could simply implement more if-statements so that the next round messages are only printed if both rat and player are alive. This way, the check for either of their deaths can simply be placed at the end of the loop.
The Big O time of this algorithm should be O(1), since there is no size involved in this method. It does contain while loops, but these are not used for iteration. The operations and checks involved should operate in constant time.
Algorithm 1: Combat Sequence (Rat)
1.	Have a scanner, player, enemy rat, and Boolean fightMode
2.	Initialize integer round to 1, and integer damage to 0
3.	DO
a.	Get string action from the player
b.	While act is not a valid combat input (AA, AC, PY)…
i.	Print message telling the player to fight
ii.	Get string action from player
c.	If round is an odd number:
i.	If act is PY
1.	Correct action, no damage taken
ii.	Else if act is AA or AC
1.	Incorrect action, damage taken by rat and player
iii.	If player and rat are alive
1.	Print messages for next round
2.	Increment round 
d.	If round is an even number:
i.	If act is PY
1.	Incorrect action, nothing happens
ii.	If act is AC
1.	Incorrect action, nothing happens
iii.	If act is AA
1.	Correct action, rat takes damage
iv.	If player and rat are alive
1.	Print messages for next round
2.	Increment round
e.	If player HP is equal to or below 0
i.	Set fightMode to false
ii.	Break from while loop
f.	If rat HP is equal to or below 0
i.	Print victory messages
ii.	Set fightMode to false
iii.	Break from while loop
The following algorithm ensures that the player never goes out-of-bounds in the map–in other words, it makes sure the player’s movement direction goes to a valid square in the map before actually moving them. This algorithm was, in its logic, very simple to create, but its actual implementation was a bit of a headache. The basic algorithm creates test values for the player’s x- and y-coordinates, based on their input. It then creates a GameMap object with these coordinates as its values, as GameMaps simply store an x- and y-coordinate. Then it checks to see if the object exists within the validMap hash table–in other words, if one of the GameMaps in validMap has the same x- and y-coordinates as the test position. If so, the method returns true, and the player will then be moved due to this. Otherwise, the method returns false, and a collision message is printed. 
The massive difficulty with this algorithm’s implementation was with hash tables’s contains() method and what objects this would actually work on. For a while, I tried to store valid map locations in arrays with size two. However, this never worked as intended because direct array comparison does not work as expected–the references are compared, not the array content. To work around this, I created the GameMap class, which really is meant to be used as a replacement class for arrays of size two, just with properly working comparability. Beyond the difficulties of implementation, though, the collision algorithm itself was not very difficult to write fully by myself. The basic idea of the logic was always to create a test position based on player input and then check if it was a valid map location. Only the implementation proved troublesome.
The Big O time of this algorithm overall is O(n) due to the contains() method used. While a hash table’s containsKey() method is faster, it would not work with how the hash table is set up. This time is not as efficient as it could be, but it could be worse.
Algorithm 2: Collision
1.	Have a hash table of Integer keys and GameMap values named validMap, player, and String move
2.	Set integer testX to method moveX with arguments move and the player’s current X
a.	moveX: 
i.	If move is A
1.	Subtract 1 from playerX
ii.	If move is D
1.	Add 1 to playerX
iii.	Return playerX
3.	Set integer testY to method moveY with arguments move and the player’s current y
a.	moveY:
i.	If move is W
1.	Add 1 to playerY
ii.	If move is S
1.	Subtract 1 from playerY
iii.	Return playerY
4.	Create a GameMap position using testX and testY
5.	If validMap contains position:
a.	Return true
6.	Else
a.	Return false
The following algorithm is the simplest of the three listed. It is what is called using the player object, as this algorithm is in the Player class, if a Boolean set to the result of the collision method returns true. This algorithm simply changes the player’s x- or y-coordinate based on their action. Dungeons of Java operates on classic WASD movement, as one might be familiar with in games like Minecraft: W is forward, A is left, S is backward, and D is right. The letter input thus determines what coordinate is changed and whether it is incremented or decremented. As this is one of the least complex algorithms in Dungeons of Java, it was very easy to write by myself.
The Big O time of this algorithm should be O(1) because there is no iteration or anything that would take more computational time. The operations done should be in constant time.
Algorithm 3: Player movement
1.	Have a string move
2.	IF move is W, THEN
a.	Increment playerY
3.	IF move is A, THEN
a.	Decrement playerX
4.	IF move is S, THEN
a.	Decrement playerY
5.	IF move is D, THEN
a.	Incremenet playerX
Data structures
An overwhelming majority of the data structures used in Dungeons of Java are hash tables. One array is also used for the sake of an initialization loop for a hash table. I found hash tables to be most useful data structure in my program because of how they can efficiently store unordered but named data. The ability to map integer values, such as for enemy stats, to String names was incredibly useful. It allows for quick lookup time, but really most valuably allows for similar information to be stored in a collection with proper names. Without hash tables, I would have to utilize a great number of variables that would not be straightforwardly stored. Placing these values together makes it a little easier to access them and update them when needed. 
Within my program, hash tables basically took the place of arrays or ArrayLists, so they are found throughout the code. Several store special map locations, and another stores enemy stats. The only array in the program simply stores the 17 map locations in the game. It is then used to initialize the validMap hash table in a loop. The sheer value of named data and data stored in pairs for games specifically seems great to me, so that is why hash tables are abundant in Dungeons of Java.

Development process
The entire development process for Dungeons of Java was both challenging and fun. One major opportunity that I encountered was after initially creating the hash table titled validMap. While I created that map and its corresponding GameMap objects for collision, I realized that I could use a similar process to simplify detection of when the player was at a certain recurring location. With this in mind, I created hash tables like normalHallways, scaryHallways, and rats. Each table stores map locations that belong to a certain category: normalHallways have no special events, scaryHallways are before or next to enemies, and rats contain rat enemies, and so forth. By doing this, the main gameplay function can check if the current player location is within one of these hash tables. Whether or not the location falls into a certain category changes what message is printed or what values and objects are passed into actionCall. This allows me to avoid using a much less clear group of if-statements that simply check individual x- and y-coordinates, based on the drawn map. It is also more scalable and easier to edit in the future.
Ironically, the most significant errors that I persistently ran into were regarding hash tables, their initialization, and their methods. Getting everything to work was a massive challenge, although it was caused largely by me forgetting certain basic aspects of Java, which I relearned through my struggle. For one, I attempted for a while to put items into a hash table in the fields section of the Enemy class. I wanted to initialize an enemy stats hash table in the Enemy class specifically. However, the issue is that the code never exactly ran because it was not in a method. I realized this was the error, and while I understood how to fix it, I decided to move the hash table to main anyways. Another error, which I prior mentioned, involved the operation of the contains() method. I initially used Integer arrays in the validMap hash table, but when compared, they would never equal one another, even if their contents were the same, because of how array comparison works in Java. To solve this, I created the GameMap class, the equals method of which compares the x- and y-values and only returns true if both coordinates match.

Future versions
There is a lot to add, edit, and refine in Dungeons of Java. Within just the basic Java code, I would like to eventually finish the other combat methods so that the game is complete. Additionally, I would like to better manage the movement system. As it stands, there is no turning in Dungeons of Java, but all the print statements assume the player has turned toward the correct opening. This makes exploring the map quite difficult if you are not already familiar with the layout like I am. Finally, I think there is room for improvement in how I handled the usage of hash tables, especially with my reasoning for using them. The containsKey method is more efficient than contains, but it is never used in my program, so perhaps this can be remedied. Overall, I would like to refine the game itself to some extent before expanding it in any way.
My biggest goal with Dungeons of Java long-term is to eventually add graphics. Whether this is in Java and includes simple text boxes and buttons or is in another language, like GameMaker’s GML, and includes enemy sprites and backgrounds, will depend on what I choose to do in the future. Regardless, I think the game would be a lot more fun with some form of graphics. From there, I could eventually add more levels and make a full game, maybe even with a story. 
I learned a lot through the process of developing this project. While it is unfinished and certainly imperfect for now, I believe strongly in its potential. Regardless of what I actually end up doing with it, I plan to work more on Dungeons of Java and hope to teach myself much more about game development and game design.
